//
//  MessagesViewController.swift
//  BoldyGiffing MessagesExtension
//
//  Created by Aaron Williams on 2017-06-30.
//  Copyright Â© 2017 SweetieApps. All rights reserved.
//

import UIKit
import Messages
import Kingfisher

extension UICollectionViewFlowLayout {
    open override func shouldInvalidateLayout(forBoundsChange newBounds: CGRect) -> Bool {
        return false
    }
}

class MessagesViewController: MSMessagesAppViewController {

    // MARK: - Outlets
    @IBOutlet weak var thumbnailCollectionView: UICollectionView!
    @IBOutlet weak var flowLayout: UICollectionViewFlowLayout!

    // MARK: - Private Properties
    private let dataSource = CollectionViewDataSource()
    private let cache = NSCache<NSString, AnyObject>()
    private var pickerVisible: Bool = false
    private var headerOffset: CGPoint {
        let attributes = thumbnailCollectionView.layoutAttributesForSupplementaryElement(ofKind: UICollectionView.elementKindSectionHeader, at: IndexPath(item: 0, section: 0))
        let offsetY = attributes?.frame.maxY ?? 0
        return CGPoint(x: 0, y: offsetY)
    }

    // MARK: - Lifecycle
    override func viewDidLoad() {
        super.viewDidLoad()
                
        thumbnailCollectionView.delegate = self
        thumbnailCollectionView.dataSource = dataSource
        thumbnailCollectionView.prefetchDataSource = dataSource

        thumbnailCollectionView.register(ThumbnailCell.self, forCellWithReuseIdentifier: thumbmailCellIdentifier)
        thumbnailCollectionView.register(CharacterPickerView.self, forSupplementaryViewOfKind: UICollectionView.elementKindSectionHeader, withReuseIdentifier: characterPickerViewIdentifier)
        
        NotificationCenter.default.addObserver(self, selector: #selector(dataSetUpdated), name: dataSetUpdatedNotification, object: nil)
        NotificationCenter.default.addObserver(self, selector: #selector(closeCharacterPicker), name: loadCharacterNotification, object: nil)
        NotificationCenter.default.addObserver(self, selector: #selector(closeCharacterPicker), name: closePickerNotification, object: nil)
    }

    deinit {
        NotificationCenter.default.removeObserver(self)
    }

    @objc func closeCharacterPicker() {
        UIView.animate(withDuration: 0.4, delay: 0, usingSpringWithDamping: 0.8, initialSpringVelocity: 0.8, options: .curveEaseOut, animations: {
            self.thumbnailCollectionView.contentOffset = self.headerOffset
        }, completion: nil)
    }
    
    @objc func dataSetUpdated(with notification: Notification) {
        guard
            let userInfo = notification.userInfo,
            let indexPaths = userInfo["newItems"] as? [IndexPath]
            else { return }

        if indexPaths.isEmpty {
            thumbnailCollectionView.reloadData()
        } else {
            thumbnailCollectionView.performBatchUpdates({
                self.thumbnailCollectionView.insertItems(at: indexPaths)
            }, completion: nil)
        }
        if thumbnailCollectionView.contentOffset.y < headerOffset.y {
            closeCharacterPicker()
        }
    }
    
    override func didReceiveMemoryWarning() {
        super.didReceiveMemoryWarning()
        // Dispose of any resources that can be recreated.
    }
    
    // MARK: - Conversation Handling
    
    override func willBecomeActive(with conversation: MSConversation) {
        // Called when the extension is about to move from the inactive to active state.
        // This will happen when the extension is about to present UI.
        
        // Use this method to configure the extension and restore previously stored state.

//        dataSource.fetchRandomThumbnails()
    }
    
    override func didResignActive(with conversation: MSConversation) {
        // Called when the extension is about to move from the active to inactive state.
        // This will happen when the user dissmises the extension, changes to a different
        // conversation or quits Messages.
        
        // Use this method to release shared resources, save user data, invalidate timers,
        // and store enough state information to restore your extension to its current state
        // in case it is terminated later.

        NotificationCenter.default.removeObserver(self)
    }
   
    override func didReceive(_ message: MSMessage, conversation: MSConversation) {
        // Called when a message arrives that was generated by another instance of this
        // extension on a remote device.
        
        // Use this method to trigger UI updates in response to the message.
    }
    
    override func didStartSending(_ message: MSMessage, conversation: MSConversation) {
        // Called when the user taps the send button.
    }
    
    override func didCancelSending(_ message: MSMessage, conversation: MSConversation) {
        // Called when the user deletes the message without sending it.
    
        // Use this to clean up state related to the deleted message.
    }
    
    override func willTransition(to presentationStyle: MSMessagesAppPresentationStyle) {
        // Called before the extension transitions to a new presentation style.
    
        // Use this method to prepare for the change in presentation style.
    }

    override func didTransition(to presentationStyle: MSMessagesAppPresentationStyle) {
        // Called after the extension transitions to a new presentation style.

        // Use this method to finalize any behaviors associated with the change in presentation style.
        thumbnailCollectionView.reloadSections(IndexSet(integer: 0))
    }

    // MARK: - Actions
    @objc private func pauseThumbnails() {
        thumbnailCollectionView.visibleCells.forEach {
            guard let cell = $0 as? ThumbnailCell else { return }

            cell.set(animating: false)
        }
    }

    private func insertGif(for cacheKey: String) {
        guard let conversation = activeConversation else { return }

        let cachePath = ImageCache.default.cachePath(forKey: cacheKey)
        let url = URL(fileURLWithPath: cachePath)
        
        let filename = UUID().uuidString + ".gif"
        var tempUrl = URL(fileURLWithPath: NSTemporaryDirectory(), isDirectory: true)
        tempUrl.appendPathComponent(filename)
        // Only insert the image once it is cached and reachable
        do {
            try FileManager.default.copyItem(at: url, to: tempUrl)
            
            _ = try tempUrl.checkResourceIsReachable()
            conversation.insertAttachment(tempUrl, withAlternateFilename: nil, completionHandler: { [weak self] _ in
                self?.requestPresentationStyle(.compact)
            })
        }
        catch {
            print(error)
//            self.insertGif(for: cacheKey)
        }
    }
    
    func toggleCharacterPicker() {
        if pickerVisible {
            thumbnailCollectionView.scrollToItem(at: IndexPath(item: 1, section: 0), at: .top, animated: true)
            pickerVisible = !pickerVisible
        } else {
            if let attributes = thumbnailCollectionView.layoutAttributesForSupplementaryElement(ofKind: UICollectionView.elementKindSectionHeader, at: IndexPath(item: 0, section: 0)) {
                let headerTop = CGPoint(x: 0, y: attributes.frame.minY - thumbnailCollectionView.contentInset.top)

                UIView.animate(withDuration: 0.3) {
                    self.thumbnailCollectionView.contentOffset = headerTop
                }
                pickerVisible = !pickerVisible
            }
        }
    }

    //MARK: - ScrollViewDelegate
    func scrollViewDidEndScrollingAnimation(_ scrollView: UIScrollView) {
        NSObject.cancelPreviousPerformRequests(withTarget: self)

        thumbnailCollectionView.visibleCells.forEach {
            guard let cell = $0 as? ThumbnailCell else { return }

            cell.set(animating: true)
        }
    }

    func scrollViewWillEndDragging(_ scrollView: UIScrollView, withVelocity velocity: CGPoint, targetContentOffset: UnsafeMutablePointer<CGPoint>) {
        if scrollView.contentOffset.y < headerOffset.y {
            toggleCharacterPicker()
        }
    }

    func scrollViewDidScroll(_ scrollView: UIScrollView) {
        NSObject.cancelPreviousPerformRequests(withTarget: self)
        perform(#selector(UIScrollViewDelegate.scrollViewDidEndScrollingAnimation), with: nil, afterDelay: 0)
        perform(#selector(self.pauseThumbnails), with: nil)

        let contentOffset = scrollView.contentOffset.y

        pickerVisible = contentOffset < headerOffset.y
    }
}

//MARK: - CollectionViewDelegate
extension MessagesViewController: UICollectionViewDelegate {

    func collectionView(_ collectionView: UICollectionView, didHighlightItemAt indexPath: IndexPath) {
        return
    }

    func collectionView(_ collectionView: UICollectionView, didUnhighlightItemAt indexPath: IndexPath) {
        return
    }

    func collectionView(_ collectionView: UICollectionView, didSelectItemAt indexPath: IndexPath) {
        guard let cell = collectionView.cellForItem(at: indexPath) as? ThumbnailCell else { return }

        let gif = dataSource.dataSet[indexPath.item]

        KingfisherManager.shared.retrieveImage(
            with: gif.fullSizeURL) { receivedSize, totalSize in
                print(totalSize/receivedSize)
            } completionHandler: { [weak self] result in
                switch result {
                case let .success(result):
                    self?.insertGif(for: result.source.cacheKey)
                    cell.set(loading: false)
                    cell.set(animating: true)
                case .failure:
                    cell.set(loading: false)
                }
            }
    }

    func collectionView(_ collectionView: UICollectionView, didDeselectItemAt indexPath: IndexPath) {
        guard let cell = collectionView.cellForItem(at: indexPath) as? ThumbnailCell else { return }

        cell.set(animating: true)
    }

    func collectionView(_ collectionView: UICollectionView, willDisplay cell: UICollectionViewCell, forItemAt indexPath: IndexPath) {
        guard let cell = cell as? ThumbnailCell else { return }

        cell.imageView.isHidden = false

        if indexPath.row == dataSource.dataSet.count - 1 {
            dataSource.fetchThumbnailsWithOffset()
        }
    }
}

//MARK: - CollectionViewDelegateFlowLayout
extension MessagesViewController: UICollectionViewDelegateFlowLayout {
    func collectionView(_ collectionView: UICollectionView, layout collectionViewLayout: UICollectionViewLayout, referenceSizeForHeaderInSection section: Int) -> CGSize {

        let viewHeight = view.frame.height - (view.safeAreaInsets.top + view.safeAreaInsets.bottom)

        let height = presentationStyle == .compact ? viewHeight : 233

        return CGSize(width: collectionView.bounds.width, height: height)
    }

    func collectionView(_ collectionView: UICollectionView, layout collectionViewLayout: UICollectionViewLayout, sizeForItemAt indexPath: IndexPath) -> CGSize {
        let numberOfItems: CGFloat = 3.0
        let itemSpacing: CGFloat = 5.0
        let availableWidth = thumbnailCollectionView.bounds.width - (itemSpacing * (numberOfItems - 1))
        let width = availableWidth / numberOfItems
        return CGSize(width: width, height: width * 0.8)
    }
}
