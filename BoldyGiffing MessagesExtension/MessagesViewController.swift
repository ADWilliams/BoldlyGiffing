//
//  MessagesViewController.swift
//  BoldyGiffing MessagesExtension
//
//  Created by Aaron Williams on 2017-06-30.
//  Copyright Â© 2017 SweetieApps. All rights reserved.
//

import UIKit
import Messages
import Kingfisher

extension UICollectionViewFlowLayout {
    open override func shouldInvalidateLayout(forBoundsChange newBounds: CGRect) -> Bool {
        return false
    }
}

class MessagesViewController: MSMessagesAppViewController, UICollectionViewDelegate, UICollectionViewDelegateFlowLayout {

    // MARK: - Outlets
    @IBOutlet weak var thumbnailCollectionView: UICollectionView!
    @IBOutlet weak var characterPickerView: CharacterPickerView!
    @IBOutlet weak var flowLayout: UICollectionViewFlowLayout!
    @IBOutlet weak var characterPickerBottomConstraint: NSLayoutConstraint!
    
    // MARK: - Private Properties
    private let dataSource = CollectionViewDataSource()
    private let cache = NSCache<NSString, AnyObject>()
    private var pickerVisible: Bool = false

    // MARK: - Lifecycle
    override func viewDidLoad() {
        super.viewDidLoad()
        
        KingfisherManager.shared.cache.pathExtension = "gif"
        
        thumbnailCollectionView.delegate = self
        thumbnailCollectionView.dataSource = dataSource
        thumbnailCollectionView.prefetchDataSource = dataSource
        
        thumbnailCollectionView.register(ThumbnailCell.self, forCellWithReuseIdentifier: thumbmailCellIdentifier)
        
        NotificationCenter.default.addObserver(self, selector: #selector(dataSetUpdated), name: dataSetUpdatedNotification, object: nil)
        NotificationCenter.default.addObserver(self, selector: #selector(closeCharacterPicker), name: loadCharacterNotification, object: nil)
        NotificationCenter.default.addObserver(self, selector: #selector(closeCharacterPicker), name: closePickerNotification, object: nil)
    }

    deinit {
        NotificationCenter.default.removeObserver(self)
    }

    @objc func closeCharacterPicker() {
        toggleCharacterPicker()
    }
    
    @objc func dataSetUpdated(with notification: Notification) {
        guard
            let userInfo = notification.userInfo,
            let indexPaths = userInfo["newItems"] as? [IndexPath]
            else { return }

        if indexPaths.isEmpty {
            thumbnailCollectionView.reloadData()
        } else {
            thumbnailCollectionView.performBatchUpdates({
                self.thumbnailCollectionView.insertItems(at: indexPaths)
            }, completion: nil)
        }
    }
    
    override func didReceiveMemoryWarning() {
        super.didReceiveMemoryWarning()
        // Dispose of any resources that can be recreated.
    }
    
    // MARK: - Conversation Handling
    
    override func willBecomeActive(with conversation: MSConversation) {
        // Called when the extension is about to move from the inactive to active state.
        // This will happen when the extension is about to present UI.
        
        // Use this method to configure the extension and restore previously stored state.

//        dataSource.fetchRandomThumbnails()
    }
    
    override func didResignActive(with conversation: MSConversation) {
        // Called when the extension is about to move from the active to inactive state.
        // This will happen when the user dissmises the extension, changes to a different
        // conversation or quits Messages.
        
        // Use this method to release shared resources, save user data, invalidate timers,
        // and store enough state information to restore your extension to its current state
        // in case it is terminated later.

        NotificationCenter.default.removeObserver(self)
    }
   
    override func didReceive(_ message: MSMessage, conversation: MSConversation) {
        // Called when a message arrives that was generated by another instance of this
        // extension on a remote device.
        
        // Use this method to trigger UI updates in response to the message.
    }
    
    override func didStartSending(_ message: MSMessage, conversation: MSConversation) {
        // Called when the user taps the send button.
    }
    
    override func didCancelSending(_ message: MSMessage, conversation: MSConversation) {
        // Called when the user deletes the message without sending it.
    
        // Use this to clean up state related to the deleted message.
    }
    
    override func willTransition(to presentationStyle: MSMessagesAppPresentationStyle) {
        // Called before the extension transitions to a new presentation style.
    
        // Use this method to prepare for the change in presentation style.
    }
    
    override func didTransition(to presentationStyle: MSMessagesAppPresentationStyle) {
        // Called after the extension transitions to a new presentation style.
    
        // Use this method to finalize any behaviors associated with the change in presentation style.
        thumbnailCollectionView.reloadSections(IndexSet(integer: 0))
    }

    // MARK: - Actions
    @objc private func pauseThumbnails() {
        thumbnailCollectionView.visibleCells.forEach {
            guard let cell = $0 as? ThumbnailCell else { return }

            cell.set(animating: false)
        }
    }

    private func insertGif(for cacheKey: String) {
        guard let conversation = activeConversation else { return }

        let cachePath = ImageCache.default.cachePath(forKey: cacheKey)
        let url = URL(fileURLWithPath: cachePath)

        // Only insert the image once it is cached and reachable
        do {
            _ = try url.checkResourceIsReachable()
            conversation.insertAttachment(url, withAlternateFilename: nil, completionHandler: { [weak self] _ in
                self?.requestPresentationStyle(.compact)
            })
        }
        catch {
            print(error)
            self.insertGif(for: cacheKey)
        }
    }

    // MARK: - CollectionViewDelegate

    func collectionView(_ collectionView: UICollectionView, didHighlightItemAt indexPath: IndexPath) {
        return
    }

    func collectionView(_ collectionView: UICollectionView, didUnhighlightItemAt indexPath: IndexPath) {
        return
    }

    func collectionView(_ collectionView: UICollectionView, didSelectItemAt indexPath: IndexPath) {
        guard let cell = collectionView.cellForItem(at: indexPath) as? ThumbnailCell else { return }

        let gif = dataSource.dataSet[indexPath.item]
        
        KingfisherManager.shared.retrieveImage(with: gif.fullSizeURL, options: nil, progressBlock: { receivedSize, totalSize in
            // progress
            print(totalSize/receivedSize)
            cell.set(loading: true)
        }) { [weak self] image, error, cacheType, url in
            guard
                error == nil else {
                    cell.set(loading: false)
                    return
            }

            self?.insertGif(for: gif.fullSizeURL.cacheKey)
            cell.set(loading: false)
            cell.set(animating: true)
        }
    }

    func collectionView(_ collectionView: UICollectionView, didDeselectItemAt indexPath: IndexPath) {
        guard let cell = collectionView.cellForItem(at: indexPath) as? ThumbnailCell else { return }

        cell.set(animating: true)
    }

    func collectionView(_ collectionView: UICollectionView, willDisplay cell: UICollectionViewCell, forItemAt indexPath: IndexPath) {
        guard let cell = cell as? ThumbnailCell else { return }

        cell.imageView.isHidden = false
    }

    func scrollViewDidEndScrollingAnimation(_ scrollView: UIScrollView) {
        NSObject.cancelPreviousPerformRequests(withTarget: self)

        thumbnailCollectionView.visibleCells.forEach {
            guard let cell = $0 as? ThumbnailCell else { return }

            cell.set(animating: true)
        }
    }
    
    func scrollViewWillEndDragging(_ scrollView: UIScrollView, withVelocity velocity: CGPoint, targetContentOffset: UnsafeMutablePointer<CGPoint>) {
        if scrollView.contentOffset.y < 0 {
            toggleCharacterPicker()
        }
    }
    
    func scrollViewDidEndDecelerating(_ scrollView: UIScrollView) {
        if scrollView.contentOffset.y >= scrollView.contentSize.height - scrollView.frame.height {
            dataSource.fetchThumbnailsWithOffset()
        }
    }

    func scrollViewDidScroll(_ scrollView: UIScrollView) {
        NSObject.cancelPreviousPerformRequests(withTarget: self)
        perform(#selector(UIScrollViewDelegate.scrollViewDidEndScrollingAnimation), with: nil, afterDelay: 0)
        perform(#selector(self.pauseThumbnails), with: nil)

        if scrollView.contentOffset.y > 0 && pickerVisible {
            toggleCharacterPicker()
            return
        }

        let contentOffset = scrollView.contentOffset.y

        if contentOffset < 0 {
            let constant = contentOffset
            print(scrollView.contentOffset.y)
            print(characterPickerBottomConstraint.constant)

            if !pickerVisible {
                UIView.animate(
                    withDuration: 0.2,
                    delay: 0.0,
                    usingSpringWithDamping: 0.2,
                    initialSpringVelocity: 6.0,
                    options: .curveLinear,
                    animations: {
                        self.characterPickerBottomConstraint.constant = constant
                        self.view.layoutIfNeeded()

                },
                    completion: nil
                )
            }
        }
    }
    
    func toggleCharacterPicker() {
        UIView.animate(
            withDuration: 0.5,
            delay: 0,
            usingSpringWithDamping: 0.8,
            initialSpringVelocity: 0.5,
            options: .curveEaseOut,
            animations: {
                let constant: CGFloat
                if #available(iOS 11, *) {
                    constant = self.pickerVisible ? 0 : -(self.view.bounds.height - self.view.safeAreaInsets.bottom)
                }else {
                    constant = self.pickerVisible ? 0 : -(self.view.bounds.height - self.bottomLayoutGuide.length)
                }
                self.characterPickerBottomConstraint.constant = constant
                self.view.layoutIfNeeded()
        },
            completion: nil
        )
        pickerVisible = !pickerVisible
    }

    // MARK: - FlowLayoutDelegate
    func collectionView(_ collectionView: UICollectionView, layout collectionViewLayout: UICollectionViewLayout, sizeForItemAt indexPath: IndexPath) -> CGSize {
        let numberOfItems: CGFloat = 3.0
        let itemSpacing: CGFloat = 5.0
        let availableWidth = thumbnailCollectionView.bounds.width - itemSpacing * (numberOfItems + 2)
        let width = min(availableWidth / numberOfItems, 150)
        return CGSize(width: width, height: width * 0.8)
    }
}
